   %% Template Exam Modelling and Control of Manipulators
clc;
close all;
clear;
addpath('include'); % put relevant functions inside the /include folder 

%% Compute the geometric model for the given manipulator

iTj_0 = BuildTree();
disp('iTj_0')
disp(iTj_0);
jointType = [0 0 0 0 0 1 0]; % specify two possible link type: Rotational, Prismatic.
geometricModel = geometricModel(iTj_0,jointType);

%% Q1.3
 %task dependant
T7ee=[1 0 0 0;
      0 1 0 0;
      0 0 1 0.060;
      0 0 0 1];

Tb_n=geometricModel.getTransformWrtBase(7);
Tb_e=Tb_n*T7ee;
disp("Transformation matrix from the base to the EE:");
disp(Tb_e);

T2_6= geometricModel.getTransform6wrt2(6);
disp("Transformation matrix from frame 2 to 6:");
disp(T2_6);
%Inverse
ident=[0 0 0 1];
Rotation_matrix= T2_6(1:3, 1:3);
Pose_26= T2_6(1:3,4);

Transformation_62=[Rotation_matrix' ((-Rotation_matrix')*Pose_26); ident];

disp("Transformation matrix from frame 6 to 2:");
disp(Transformation_62);

%% Q1.4 Simulation
% Given the following configurations compute the Direct Geometry for the manipulator

% Compute iTj : transformation between the base of the joint <i>
% and its end-effector taking into account the actual rotation/traslation of the joint
qi = [pi/4, -pi/4, 0, -pi/4, 0, 0.15, pi/4];
geometricModel.updateDirectGeometry(qi)
disp('iTj')
disp(geometricModel.iTj);

% Compute the transformation of the ee w.r.t. the robot base
bTe = geometricModel.getTransformWrtBase(length(jointType));  
disp('bTe')
disp(bTe)

% Show simulation ?
show_simulation = true;

% Set initial and final joint positions
qf = [5*pi/12, -pi/3, 0, -pi/4, 0, 0.18, pi/5];

%%%%%%%%%%%%% SIMULATION LOOP %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Simulation variables
% simulation time definition 
samples = 100;
t_start = 0.0;
t_end = 10.0;
dt = (t_end-t_start)/samples;
t = t_start:dt:t_end; 

pm = plotManipulators(show_simulation);
pm.initMotionPlot(t);

qSteps =[linspace(qi(1),qf(1),samples)', ...
    linspace(qi(2),qf(2),samples)', ...
    linspace(qi(3),qf(3),samples)', ...
    linspace(qi(4),qf(4),samples)', ...
    linspace(qi(5),qf(5),samples)', ...
    linspace(qi(6),qf(6),samples)', ...
    linspace(qi(7),qf(7),samples)'];

% LOOP 
for i = 1:samples

    brij= zeros(3,geometricModel.jointNumber);
    q = qSteps(i,1:geometricModel.jointNumber)';
    % Updating transformation matrices for the new configuration 
    geometricModel.updateDirectGeometry(q)
    % Get the transformation matrix from base to the tool
    bTe = geometricModel.getTransformWrtBase(length(jointType)); 

    %% ... Plot the motion of the robot 
    if (rem(i,0.1) == 0) % only every 0.1 sec
        for j=1:geometricModel.jointNumber
            bTi(:,:,j) = geometricModel.getTransformWrtBase(j); 
        end
        pm.plotIter(bTi)
    end

end

pm.plotFinalConfig(bTi)

disp(geometricModel.q -qf') %should be zero
%% Q1.5

qf = [5*pi/12, -pi/3, 0, -pi/4, 0, 0.18, pi/5];
geometricModel.updateDirectGeometry(qf);

km = kinematicModel(geometricModel);

J= km.getJacobianOfLinkWrtBase(6);
disp("Jacobian of Link 6 with respect to base");
disp(J);

%% Q1.6
qf = [5*pi/12, -pi/3, 0, -pi/4, 0, 0.18, pi/5];
geometricModel.updateDirectGeometry(qf)

km = kinematicModel(geometricModel);
km.updateJacobian;
disp("Jacobian of the end effector with respect to base");
disp(km.J);

%% Q1.7
qf = [0.7 -0.1 1 -1 0 0.03 1.3];
q_velocities = [0.9 0.1 -0.2 0.3 -0.8 0.5 0];

geometricModel.updateDirectGeometry(qf)

km = kinematicModel(geometricModel);
km.updateJacobian;

disp("Jacobian of the end effector with respect to base");
disp(km.J);

Tb_n= geometricModel.getTransformWrtBase(7);

%including a tool
% T7ee=[1 0 0 0;
      0 1 0 0;
      0 0 1 0.060;
      0 0 0 1];

%Tb_e=Tb_n*T7ee;
disp("Transformation matrix from base to end effector, projected in base frame:");
disp(Tb_n);

Te_b= inv(Tb_n);
disp("Inverse of Tb_e");
disp(Te_b);

twist_ee= km.J*q_velocities';
disp("Velocity of end effector in base frame:")
disp(twist_ee);

%using the adjoint(T^-1)
R= Te_b(1:3,1:3);
P= Te_b(1:3,4);
Adj= [R zeros(3);skew(P)*R R];

%inverse of adjoint is the same of adj of inverse
R_1= Tb_e(1:3,1:3);
P_1= Tb_e(1:3,4);
Adj_Tbe= [R_1 zeros(3);skew(P_1)*R_1 R_1];

V_e_o= Adj*twist_ee;
V_adj= inv(Adj_Tbe)*twist_ee;

disp("Velocity of end effector, projected in end effector frame:");
disp(V_e_o);
disp(V_adj);

%using rotation matrx
angular= twist_ee(1:3,:);
linear= twist_ee(4:6,:);
angular_ee_frame = R_1'*angular;
r_en=R_1*[0 0 0.06]';
linear_ee_frame= R_1'*[cross(angular,P_1)] + R_1'*linear;
disp("Velocity of End effector, projected in the e frame:");
disp(angular_ee_frame);
disp(linear_ee_frame);


